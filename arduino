#include <Adafruit_GFX.h>
#include <Adafruit_ST7789.h>
#include <SPI.h>
#include <Adafruit_NeoPixel.h>
#include <math.h>

// ====================== 1. 硬體接腳設定 (ESP32-C3) ======================
// 螢幕接腳 (依據你的接線，若有不同請修改)
#define TFT_CS   2
#define TFT_DC   1
#define TFT_RST  10
#define TFT_MOSI 6
#define TFT_SCK  4

// LED 與 馬達接腳
#define LED_PIN     3      // WS2812 訊號腳
#define LED_COUNT   4      // 假設你有 4 顆燈 (或 1 顆)

#define MOTOR_LEFT_PIN   8 // 左馬達
#define MOTOR_RIGHT_PIN  9 // 右馬達

// ====================== 2. 亮度與色彩設定 (關鍵修改) ======================
// 為了透出手機殼，這裡設比較亮 (範圍 0-255)
// ⚠️ 如果太燙，請調低至 120 左右
#define MASTER_BRIGHTNESS 180 

// ====================== 物件宣告 ======================
Adafruit_ST7789 tft = Adafruit_ST7789(TFT_CS, TFT_DC, TFT_RST);
GFXcanvas16 eyeCanvas(240, 240); 

// ⚠️ 注意：如果你發現顏色怪怪的 (例如暖光變藍光)，請把 NEO_GRB 改成 NEO_RGB
Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);

// ====================== 模式定義 ======================
enum Mode {
  MODE_ANCHOR     = 1, // 呼吸 (Breathing) - 暖光
  MODE_ANCHOR_2   = 2, // 心跳 (Heartbeat) - 紅光
  MODE_SHIFT      = 3, // 切換 (Bilateral) - 冷白光
  MODE_SPARK_LOW  = 4, // 燭光 (Candle) - 金黃
  MODE_SPARK_LONE = 5, // 燭光 (Spark) - 金黃
  MODE_AMBIENT    = 6  // 待機 (Idle) - 淡暖白
};

uint8_t currentMode = MODE_ANCHOR;
String serialBuffer;

// ====================== 眼睛參數 ======================
int eyeRadius   = 55;
int irisRadius  = 26;
int pupilRadius = 12;
float eyeOffsetX = 0.0f; float eyeOffsetY = 0.0f;
float moveTargetX = 0.0f; float moveTargetY = 0.0f;
float moveStartX = 0.0f; float moveStartY = 0.0f;
unsigned long moveStartTime = 0; unsigned long moveDuration = 1000;
unsigned long nextMoveTime = 0; bool moving = false;
bool blinkActive = false; unsigned long blinkStartTime = 0;
unsigned long blinkDuration = 180; unsigned long nextBlinkTime = 0; float blinkAmount = 0.0f;

// ====================== 狀態變數 ======================
unsigned long lastShiftTime = 0;
bool shiftSideLeft = true; 
const int SHIFT_INTERVAL = 800; // 左右切換速度

unsigned long lastFlickerTime = 0;
uint8_t currentFlickerBright = 100;

// 呼吸參數 (4秒吸 / 6秒吐)
const int INHALE_TIME = 4000; 
const int EXHALE_TIME = 6000; 
unsigned long breathCycleStart = 0;

// ====================== 工具函式 ======================
float clamp01(float v) {
  if (v < 0.0f) return 0.0f;
  if (v > 1.0f) return 1.0f;
  return v;
}

float easeInOut(float t) {
  t = clamp01(t);
  return t * t * (3.0f - 2.0f * t);
}

// 設定顏色 (自動套用全域亮度)
void setLedColor(int index, uint8_t r, uint8_t g, uint8_t b, float visualIntensity) {
  visualIntensity = clamp01(visualIntensity);
  strip.setPixelColor(index, strip.Color(
    (uint8_t)(r * visualIntensity),
    (uint8_t)(g * visualIntensity),
    (uint8_t)(b * visualIntensity)
  ));
}

void motorsOff() {
  digitalWrite(MOTOR_LEFT_PIN, LOW);
  digitalWrite(MOTOR_RIGHT_PIN, LOW);
}

void motorsOn() {
  digitalWrite(MOTOR_LEFT_PIN, HIGH);
  digitalWrite(MOTOR_RIGHT_PIN, HIGH);
}

// ====================== 模式邏輯 (核心) ======================

// [MODE 1] THE ANCHOR (呼吸模式 - 暖光)
void updateMode_Anchor(unsigned long now) {
  unsigned long cycleTime = INHALE_TIME + EXHALE_TIME;
  unsigned long timeInCycle = (now - breathCycleStart) % cycleTime;

  float brightness = 0.0f;
  bool isInhale = (timeInCycle < INHALE_TIME);

  if (isInhale) {
    // 吸氣: 變亮 (Ease Out)
    float progress = (float)timeInCycle / INHALE_TIME;
    brightness = -1.0f * progress * (progress - 2.0f); 
    motorsOn(); // 吸氣時震動引導
  } else {
    // 吐氣: 變暗 (Linear)
    float progress = (float)(timeInCycle - INHALE_TIME) / EXHALE_TIME;
    brightness = 1.0f - progress; 
    motorsOff();
  }

  // 確保最低亮度不為 0，讓手機殼看起來隨時都有微光
  float visualLevel = 0.2f + (brightness * 0.8f); 
  
  for(int i=0; i<LED_COUNT; i++) {
    // R=255, G=140, B=40 -> 經典琥珀暖色
    setLedColor(i, 255, 140, 40, visualLevel); 
  }
  strip.show();
}

// [MODE 3] THE SHIFT (左右切換 - 冷白光)
void updateMode_Shift(unsigned long now) {
  if (now - lastShiftTime > SHIFT_INTERVAL) {
    shiftSideLeft = !shiftSideLeft; 
    lastShiftTime = now;
  }

  float progress = (now - lastShiftTime) / (float)SHIFT_INTERVAL;
  float fadeOut = 1.0f - progress;
  float fadeIn  = progress;

  float leftLevel  = shiftSideLeft ? fadeIn : fadeOut;
  float rightLevel = shiftSideLeft ? fadeOut : fadeIn;

  // R=200, G=220, B=255 -> 冷白/淡藍
  setLedColor(0, 200, 220, 255, 0.2f + leftLevel * 0.8f);
  setLedColor(1, 200, 220, 255, 0.2f + leftLevel * 0.8f);
  setLedColor(2, 200, 220, 255, 0.2f + rightLevel * 0.8f);
  setLedColor(3, 200, 220, 255, 0.2f + rightLevel * 0.8f);
  strip.show();

  // 震動邏輯: 切換瞬間給一個 Tap
  if ((now - lastShiftTime) < 150) {
    if (shiftSideLeft) {
      digitalWrite(MOTOR_LEFT_PIN, HIGH);
      digitalWrite(MOTOR_RIGHT_PIN, LOW);
    } else {
      digitalWrite(MOTOR_LEFT_PIN, LOW);
      digitalWrite(MOTOR_RIGHT_PIN, HIGH);
    }
  } else {
    motorsOff();
  }
}

// [MODE 5] THE SPARK (燭光 - 金黃)
void updateMode_Spark(unsigned long now) {
  if (now - lastFlickerTime > random(50, 150)) {
    lastFlickerTime = now;
    currentFlickerBright = random(80, 220); // 隨機亮度
  }
  float visualLevel = currentFlickerBright / 255.0f;
  
  for(int i=0; i<LED_COUNT; i++) {
    float localVar = random(90, 110) / 100.0f;
    // R=255, G=100, B=20 -> 深金黃色
    setLedColor(i, 255, 100, 20, visualLevel * localVar); 
  }
  strip.show();

  // 隨機微震動 (Purr)
  if (random(0, 1000) > 985) { 
    motorsOn();
    delay(20); 
    motorsOff();
  } else {
    motorsOff();
  }
}

// [MODE 6] AMBIENT (待機 - 柔白)
void updateMode_Ambient(unsigned long now) {
  const unsigned long driftCycle = 12000;
  float phase = (now % driftCycle) / (float)driftCycle;
  float breath = 0.5f - 0.5f * cos(2.0f * PI * phase);
  
  // 待機時稍微亮一點點，才不會像壞掉
  float visualLevel = 0.15f + (breath * 0.25f); 

  for(int i=0; i<LED_COUNT; i++) {
    setLedColor(i, 255, 220, 180, visualLevel); 
  }
  strip.show();
  motorsOff();
}

// [MODE 2] HEARTBEAT (Overwhelm)
void updateMode_Overwhelm(unsigned long now) {
  unsigned long beatCycle = 1000; 
  unsigned long t = now % beatCycle;
  bool beat = (t < 100) || (t > 200 && t < 300); 
  float lightPulse = beat ? 1.0f : 0.3f;
  
  for(int i=0; i<LED_COUNT; i++) {
    setLedColor(i, 255, 50, 50, lightPulse); // 紅色警示
  }
  strip.show();
  if (beat) motorsOn(); else motorsOff();
}

// ====================== 眼睛動畫邏輯 ======================
float getBaseLidForMode() {
  switch (currentMode) {
    case MODE_ANCHOR:     return 0.60f; // 瞇眼放鬆
    case MODE_SHIFT:      return 0.10f; // 張開專注
    case MODE_SPARK_LONE: return 0.20f;
    case MODE_AMBIENT:    return 0.30f;
    default:              return 0.20f;
  }
}

void updateEyePhysics(unsigned long now) {
  // 眨眼邏輯
  if (!blinkActive) {
    if (now >= nextBlinkTime) {
      blinkActive = true;
      blinkStartTime = now;
    }
    blinkAmount = 0.0f;
  } else {
    float t = (float)(now - blinkStartTime) / (float)blinkDuration;
    if (t >= 1.0f) {
      blinkActive = false;
      blinkAmount = 0.0f;
      nextBlinkTime = now + random(2000, 6000); 
    } else {
      blinkAmount = (t < 0.5f) ? (t * 2.0f) : ((1.0f - t) * 2.0f);
    }
  }

  // 眼球移動邏輯
  if (!moving && now >= nextMoveTime) {
    float rangeX = (currentMode == MODE_SHIFT) ? 35.0f : 8.0f; 
    float rangeY = 5.0f;
    
    moveStartX = eyeOffsetX;
    moveStartY = eyeOffsetY;
    
    if (currentMode == MODE_SHIFT) {
       moveTargetX = (eyeOffsetX > 0) ? -rangeX : rangeX;
       moveTargetY = random(-3, 4);
    } else {
       moveTargetX = random(-rangeX, rangeX);
       moveTargetY = random(-rangeY, rangeY);
    }
    
    moveDuration = random(800, 1500);
    moveStartTime = now;
    moving = true;
    nextMoveTime = now + moveDuration + random(1000, 4000);
  }

  if (moving) {
    float t = (float)(now - moveStartTime) / (float)moveDuration;
    if (t >= 1.0f) {
      moving = false;
      eyeOffsetX = moveTargetX;
      eyeOffsetY = moveTargetY;
    } else {
      float e = easeInOut(t);
      eyeOffsetX = moveStartX + (moveTargetX - moveStartX) * e;
      eyeOffsetY = moveStartY + (moveTargetY - moveStartY) * e;
    }
  }
}

void drawEye(float lidLevel) {
  eyeCanvas.fillScreen(ST77XX_BLACK);
  int cx1 = 80, cx2 = 160, cy = 120;
  lidLevel = clamp01(lidLevel + blinkAmount);
  int lidH = (int)(lidLevel * eyeRadius);

  // 左眼
  eyeCanvas.fillCircle(cx1, cy, eyeRadius, ST77XX_WHITE);
  eyeCanvas.fillCircle(cx1 + eyeOffsetX, cy + eyeOffsetY, irisRadius, tft.color565(30, 140, 255));
  eyeCanvas.fillCircle(cx1 + eyeOffsetX, cy + eyeOffsetY, pupilRadius, ST77XX_BLACK);
  if(lidH > 0) {
     eyeCanvas.fillRect(cx1 - eyeRadius, cy - eyeRadius, eyeRadius*2, lidH, ST77XX_BLACK); 
     eyeCanvas.fillRect(cx1 - eyeRadius, cy + eyeRadius - lidH, eyeRadius*2, lidH, ST77XX_BLACK); 
  }

  // 右眼
  eyeCanvas.fillCircle(cx2, cy, eyeRadius, ST77XX_WHITE);
  eyeCanvas.fillCircle(cx2 + eyeOffsetX*0.9, cy + eyeOffsetY, irisRadius, tft.color565(30, 140, 255));
  eyeCanvas.fillCircle(cx2 + eyeOffsetX*0.9, cy + eyeOffsetY, pupilRadius, ST77XX_BLACK);
  if(lidH > 0) {
     eyeCanvas.fillRect(cx2 - eyeRadius, cy - eyeRadius, eyeRadius*2, lidH, ST77XX_BLACK); 
     eyeCanvas.fillRect(cx2 - eyeRadius, cy + eyeRadius - lidH, eyeRadius*2, lidH, ST77XX_BLACK); 
  }
  
  tft.drawRGBBitmap(0,0, eyeCanvas.getBuffer(), 240, 240);
}

// ====================== 設定與主程式 ======================
void setup() {
  delay(2000); // 讓 ESP32 USB 準備好
  Serial.begin(115200);

  Serial.println("\n>>> Nino Prototype v13 Starting... <<<");
  
  pinMode(MOTOR_LEFT_PIN, OUTPUT);
  pinMode(MOTOR_RIGHT_PIN, OUTPUT);
  
  tft.init(240, 240);
  tft.setRotation(0); // 如果眼睛倒了，改成 1 或 3
  
  strip.begin();
  strip.setBrightness(MASTER_BRIGHTNESS); // 使用加強後的亮度
  strip.show();

  drawEye(0.0f);
  breathCycleStart = millis(); 
}

void loop() {
  // 1. 讀取指令
  while (Serial.available() > 0) {
    char c = Serial.read();
    if (c == '\n') {
       if (serialBuffer.startsWith("MODE:")) {
          int m = serialBuffer.substring(5).toInt();
          if (m >= 1 && m <= 6) {
             currentMode = m;
             breathCycleStart = millis(); // 重置呼吸節奏
             lastShiftTime = millis();
             Serial.print(">>> Switched to MODE: "); Serial.println(currentMode);
          }
       }
       serialBuffer = "";
    } else if (c != '\r') {
       serialBuffer += c;
    }
  }

  unsigned long now = millis();

  // 2. 更新眼睛
  updateEyePhysics(now);
  drawEye(getBaseLidForMode());

  // 3. 更新模式
  switch(currentMode) {
    case MODE_ANCHOR:     updateMode_Anchor(now); break;
    case MODE_ANCHOR_2:   updateMode_Overwhelm(now); break;
    case MODE_SHIFT:      updateMode_Shift(now); break;
    case MODE_SPARK_LOW:
    case MODE_SPARK_LONE: updateMode_Spark(now); break;
    case MODE_AMBIENT:    updateMode_Ambient(now); break;
  }
}
